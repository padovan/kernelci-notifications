#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import jinja2
import json
import os
import sys

from collections import defaultdict
from datetime import datetime, timezone
from types import SimpleNamespace

from libs.email import *
from libs.kcidb import *


STORAGE_FILE = "found_issues.json"


def setup_jinja_template(file):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(sys.path[0], 'templates')))
    return env.get_template(file)


def exclude_already_found_and_store(issues):
    """
    Excludes issues that have already been found and store in the storage file.

    Args:
        issues: A list of dictionaries, where each dictionary represents an issue.

    Returns:
        A list of dictionaries containing only the new issues (those not in the storage file).
    """
    found_issues = {}

    # Load existing found issues from storage if the file exists
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, "r") as f:
                found_issues = json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {STORAGE_FILE}. Starting with empty issue list.")


    new_issues = []
    for issue in issues:
        issue_id = issue['id']  # Assuming 'id' is the unique identifier

        if not found_issues.get(issue_id):
            new_issues.append(issue)
            issue["sent"] = False
            issue["ignore"] = False
            found_issues[issue_id] = {
                "comment": issue["comment"],
                "type": issue["type"],
                "timestamp": issue["_timestamp"],
                "dashboard": f"https://dashboard.kernelci.org/issue/{issue["id"]}",
                "sent": issue["sent"],
                "ignore": issue["ignore"],
            }


    # Save the updated found issues to storage (overwriting the file)
    try:
        with open(STORAGE_FILE, "w") as f:
            json.dump(found_issues, f, indent=4, default=str) # indent for readability, default=str to handle datetime
    except Exception as e:
        print(f"Error saving found issues to {STORAGE_FILE}: {e}")

    return new_issues


def get_unsent_issues():
    """Collects all issues where 'sent' is False and 'ignore' is False."""
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    unsent_issues = {
        issue_id: details
        for issue_id, details in data.items()
        if not details.get("sent", False) and not details.get("ignore", False)
    }

    return unsent_issues


def mark_issue_as_sent(issue_id, msg_id):
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    if issue_id in data:
        data[issue_id]["sent"] = True
        data[issue_id]["message_id"] = msg_id

        with open(STORAGE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)


def generate_issues_summary(dbconn, service, origin, email_args):
    issues = kcidb_new_issues(dbconn)
    build_issues = []
    boot_issues = []
    for issue in issues:
        if issue["build_id"]:
            issue["type"] = "build"
            build_issues.append(issue)
        elif issue["test_id"]:
            issue["type"] = "boot"
            boot_issues.append(issue)

    new_build_issues = exclude_already_found_and_store(build_issues)
    new_boot_issues = exclude_already_found_and_store(boot_issues)
    if not new_build_issues and not new_boot_issues:
        return None

    template = setup_jinja_template('issues.txt.j2')
    report= {}
    now = datetime.now(timezone.utc)
    report["content"] = template.render(build_issues=new_build_issues, boot_issues=new_boot_issues)
    report["title"] = f"new issues summary - {now.strftime("%Y-%m-%d %H:%M %Z")}"

    send_email_report(service, report, email_args)


def generate_build_issue_report(issue, incidents):
    template = setup_jinja_template('issue_build.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, builds=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (build){snippet}"
    return report


def generate_boot_issue_report(issue, incidents):
    template = setup_jinja_template('issue_boot.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, boots=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (boot){snippet}"
    return report


def generate_issue_report(service, conn, issue_id, email_args):
    result = kcidb_issue_details(conn, issue_id)
    if not result:
        print("issue not found!")
        sys.exit(-1)
    issue = result[0]
    if issue["build_id"]:
        incidents = kcidb_build_incidents(conn, issue_id)
        report = generate_build_issue_report(issue, incidents)
    elif issue["test_id"]:
        incidents = kcidb_test_incidents(conn, issue_id)
        for incident in incidents:
            last_test = kcidb_last_test_without_issue(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            last_test = kcidb_last_test_without_issue_koike(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            incident["last_pass"] = last_test[0]["start_time"]
            incident["last_pass_commit"] = last_test[0]["git_commit_hash"]
            incident["last_pass_id"] = last_test[0]["id"]
        report = generate_boot_issue_report(issue, incidents)

    msg_id = send_email_report(service, report, email_args)

    if msg_id and email_args.update:
        mark_issue_as_sent(issue_id, msg_id)

colors = {
    'red': '\033[91m',
    'green': '\033[92m',
    'yellow': '\033[93m',
    'blue': '\033[94m',
    'reset': '\033[0m'
}


def evaluate_test_results(conn, origin):
    giturl = "https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git"
    #   giturl = "https://git.kernel.org/pub/scm/linux/kernel/git/next/linux-next.git"
    #giturl = "https://git.kernel.org/pub/scm/linux/kernel/git/broonie/regulator.git"
    branch = "master"
    tests = kcidb_tests_results(conn, origin, giturl, branch)
    print(f"origin: {origin}")
    print(f"tree: {giturl}")
    print(f"branch: {branch}")

    # First group by platform, then by path
    grouped = defaultdict(lambda: defaultdict(list))

    for t in tests:
        platform = t["environment_misc"].get("platform", "unknown")
        grouped[platform][t["path"]].append(t)

    for platform, paths in grouped.items():
        printed_platform = False

        for path, test_group in paths.items():

            unique_statuses = {t["status"] for t in test_group}
            if len(unique_statuses) == 1:
                continue

            if not printed_platform:
                sys.stdout.write(f"\nHardware: {platform}\n")
                printed_platform = True

            for t in test_group:
                if t["status"] == "PASS":
                    sys.stdout.write(f"{colors['green']}✓ {colors['reset']}")
                elif t["status"] == "FAIL":
                    sys.stdout.write(f"{colors['red']}𐄂 {colors['reset']}")
                else:
                    sys.stdout.write(f"{colors['yellow']}? {colors['reset']}")
            sys.stdout.write(f"{path}\n")


def create_and_send_issue_reports(service, conn, email_args):
    unsent_issues = get_unsent_issues()
    for issue_id, details in unsent_issues.items():
        if details["type"] != "build":
            continue
        generate_issue_report(service, conn, issue_id, email_args)


def main():
    service = gmail_setup_service()
    dbconn = kcidb_connect()
    origin = "maestro"

    parser = argparse.ArgumentParser(description="Run notifications script with subcommands.")
    parser.add_argument("--send", action="store_true", help="Send email report at the end.")
    parser.add_argument("--to", type=str, help="Recipient To: of the email")
    parser.add_argument("--cc", type=str, help="Recipient CC: of the email")
    parser.add_argument("--yes", action="store_true", help="Send email without asking for confirmation")

    subparsers = parser.add_subparsers(dest="command", required=True, help="Available subcommands")

    issues_parser = subparsers.add_parser("issues", help="Run the issue_summary function")

    issue_report_parser = subparsers.add_parser("issue_report", help="Run the issue_report function")
    issue_report_parser.add_argument("--id", type=str,
        help="Id of the issue in the Dashboard/KCIDB")
    issue_report_parser.add_argument("--send-all", action="store_true",
        help="Automatically send issue reports for supported types")
    issue_report_parser.add_argument("--update-storage", "-u", action="store_true",
        help="Update json storage as we manipulate and report issues")

    tests_parser = subparsers.add_parser("tests", help="Check test status changes")

    args = parser.parse_args()

    email_args = SimpleNamespace()
    email_args.send = args.send
    email_args.yes = args.yes
    email_args.to = args.to
    email_args.cc = args.cc
    email_args.update = args.update_storage

    if args.command == "issues":
        generate_issues_summary(dbconn, service, origin, email_args)
    elif args.command == "issue_report":
        if args.send_all:
            create_and_send_issue_reports(service, dbconn, email_args)
            return
        else:
            generate_issue_report(service, dbconn, args.id, email_args)
    elif args.command == "tests":
            evaluate_test_results(dbconn, origin)
            return


if __name__ == "__main__":
    main()