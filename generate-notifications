#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import jinja2
import json
import os
import sys
import yaml

from collections import defaultdict
from datetime import datetime, timezone
from io import StringIO
from types import SimpleNamespace

from libs.email import *
from libs.kcidb import *


STORAGE_FILE = "found_issues.json"


def setup_jinja_template(file):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(sys.path[0], 'templates')))
    return env.get_template(file)


def exclude_already_found_and_store(issues):
    """
    Excludes issues that have already been found and store in the storage file.

    Args:
        issues: A list of dictionaries, where each dictionary represents an issue.

    Returns:
        A list of dictionaries containing only the new issues (those not in the storage file).
    """
    found_issues = {}

    # Load existing found issues from storage if the file exists
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, "r") as f:
                found_issues = json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {STORAGE_FILE}. Starting with empty issue list.")


    new_issues = []
    for issue in issues:
        issue_id = issue['id']  # Assuming 'id' is the unique identifier

        if not found_issues.get(issue_id):
            new_issues.append(issue)
            issue["sent"] = False
            issue["ignore"] = False
            found_issues[issue_id] = {
                "comment": issue["comment"],
                "type": issue["type"],
                "timestamp": issue["_timestamp"],
                "dashboard": f"https://dashboard.kernelci.org/issue/{issue["id"]}",
                "sent": issue["sent"],
                "ignore": issue["ignore"],
            }


    # Save the updated found issues to storage (overwriting the file)
    try:
        with open(STORAGE_FILE, "w") as f:
            json.dump(found_issues, f, indent=4, default=str) # indent for readability, default=str to handle datetime
    except Exception as e:
        print(f"Error saving found issues to {STORAGE_FILE}: {e}")

    return new_issues


def get_unsent_issues():
    """Collects all issues where 'sent' is False and 'ignore' is False."""
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    unsent_issues = {
        issue_id: details
        for issue_id, details in data.items()
        if not details.get("sent", False) and not details.get("ignore", False)
    }

    return unsent_issues


def mark_issue_as_sent(issue_id, msg_id):
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    if issue_id in data:
        data[issue_id]["sent"] = True
        data[issue_id]["message_id"] = msg_id

        with open(STORAGE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)


def mark_issue_as_ignore(issue_id):
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    if issue_id in data:
        data[issue_id]["ignore"] = True

        with open(STORAGE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)


def read_yaml_file(filepath):
    """Reads a YAML file and returns the data as a dictionary."""
    try:
        with open(filepath, 'r') as file:
            data = yaml.safe_load(file)  # Use safe_load to avoid potential security issues
            return data
    except FileNotFoundError:
        print(f"Error: File not found at {filepath}")
        return None
    except yaml.YAMLError as exc:
        print(f"Error parsing YAML: {exc}")
        return None


def get_recipient_list(tree_name):
    """
    Read recipients from a YAML file for a given tree name.

    Args:
        tree_name (str): Name of the tree (e.g., 'android', 'stable', 'next')

    Returns:
        str: Comma-separated list of email addresses for the specified tree
             Returns None if tree is not found
    """
    try:
        data = read_yaml_file('data/recipients.yaml')

        if tree_name in data['trees']:
            recipients = data['trees'][tree_name]
            return ', '.join(recipients)

        return None

    except (KeyError, TypeError) as e:
        print(f"Error accessing tree data: {e}")
        return None


def generate_issues_summary(dbconn, service, origin, email_args):
    issues = kcidb_new_issues(dbconn, origin)
    build_issues = []
    boot_issues = []
    for issue in issues:
        if issue["build_id"]:
            issue["type"] = "build"
            build_issues.append(issue)
        elif issue["test_id"]:
            issue["type"] = "boot"
            boot_issues.append(issue)

    new_build_issues = exclude_already_found_and_store(build_issues)
    new_boot_issues = exclude_already_found_and_store(boot_issues)
    if not new_build_issues and not new_boot_issues:
        print("No new issues")
        return None

    template = setup_jinja_template('issues.txt.j2')
    report= {}
    now = datetime.now(timezone.utc)
    report["content"] = template.render(build_issues=new_build_issues, boot_issues=new_boot_issues)
    report["title"] = f"new issues summary - {now.strftime("%Y-%m-%d %H:%M %Z")}"

    send_email_report(service, report, email_args)


def generate_build_issue_report(issue, incidents):
    template = setup_jinja_template('issue_build.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, builds=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (build){snippet}"
    return report


def generate_boot_issue_report(issue, incidents):
    template = setup_jinja_template('issue_boot.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, boots=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (boot){snippet}"
    return report


def generate_issue_report(service, conn, issue_id, email_args):
    result = kcidb_issue_details(conn, issue_id)
    if not result:
        print("issue not found!")
        sys.exit(-1)
    issue = result[0]
    if issue["build_id"]:
        incidents = kcidb_build_incidents(conn, issue_id)
        report = generate_build_issue_report(issue, incidents)
    elif issue["test_id"]:
        incidents = kcidb_test_incidents(conn, issue_id)
        for incident in incidents:
            last_test = kcidb_last_test_without_issue(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            last_test = kcidb_last_test_without_issue_koike(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            incident["last_pass"] = last_test[0]["start_time"]
            incident["last_pass_commit"] = last_test[0]["git_commit_hash"]
            incident["last_pass_id"] = last_test[0]["id"]
        report = generate_boot_issue_report(issue, incidents)
    recipients = get_recipient_list(issue["tree_name"])
    msg_id = send_email_report(service, report, recipients, email_args)

    if msg_id and email_args.update:
        mark_issue_as_sent(issue_id, msg_id)


def add_to_test_results_buffer(buffer, grouped):
    has_changes = False
    for platform, configs in grouped.items():
        printed_platform = False

        for config_name, paths in configs.items():
            for path, test_group in paths.items():
                unique_statuses = {t["status"] for t in test_group}
                if len(unique_statuses) == 1:
                    continue

                if not printed_platform:
                    buffer.write(f"\nHardware: {platform}\n")
                    printed_platform = True

                buffer.write(f"- {path} ({config_name})\n")
                buffer.write(f"  last run: https://d.kernelci.org/test/{test_group[0]["id"]}\n")

                has_changes = True
                status_line = ["➜ "]

                for t in reversed(test_group):
                    if t["status"] == "PASS":
                        status_line.append("✅ ")
                    elif t["status"] == "FAIL":
                        status_line.append("❌ ")
                    else:  # Inconclusive or other statuses
                        status_line.append("⚠️ ")

                buffer.write(f"  {' '.join(status_line)}\n")
                buffer.write(f"\n")

    return has_changes


def evaluate_test_results(service, conn, origin, giturl, branch, path, email_args, recipients=None):
    buffer = StringIO()
    tests = kcidb_tests_results(conn, origin, giturl, branch, path)
    tree_name = kcidb_tree_name(conn, origin, giturl)
    buffer.write(f"Test results changes {tree_name}/{branch} (origin: {origin})\n\n")

    # Group by platform, then by config_name, then by path
    grouped = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    new_issues = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    fixed_issues = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))
    unstable_tests = defaultdict(lambda: defaultdict(lambda: defaultdict(list)))

    for t in tests:
        platform = t.get("platform", "unknown platform")
        config_name = t.get("config_name", "unknown config")
        grouped[platform][config_name][t["path"]].append(t)

    for platform, configs in grouped.items():
        for config_name, paths in configs.items():
            for path, test_group in paths.items():
                first_test = True
                possible_regression = True
                fixed_regression = True
                status_changed = False
                for t in test_group:
                    if first_test:
                        if t["status"] == "PASS":
                            possible_regression = False
                        elif t["status"] == "FAIL":
                            fixed_regression = False
                        else:
                            possible_regression = False
                            fixed_regression = False
                        first_test = False
                    else:
                        if possible_regression:
                            if t["status"] == "FAIL" and not status_changed:
                                continue
                            elif t["status"] == "FAIL" and status_changed:
                                possible_regression = False
                            elif t["status"] == "PASS":
                                status_changed = True
                            elif t["status"] != "PASS" and t["status"] != "FAIL":
                                possible_regression = False

                        if fixed_regression:
                            if t["status"] == "PASS" and not status_changed:
                                continue
                            elif t["status"] == "PASS" and status_changed:
                                fixed_regression = False
                            elif t["status"] == "FAIL":
                                status_changed = True
                            elif t["status"] != "PASS" and t["status"] != "FAIL":
                                fixed_regression = False


                if possible_regression:
                    new_issues[platform][config_name][t["path"]] = test_group
                elif fixed_regression:
                    fixed_issues[platform][config_name][t["path"]] = test_group
                else:
                    unstable_tests[platform][config_name][t["path"]] = test_group

    buffer.write(f"\n### POSSIBLE REGRESSIONS\n")
    has_changes = add_to_test_results_buffer(buffer, new_issues)
    if not has_changes:
        buffer.write(f"\nNo possible regressions observed.\n")

    buffer.write(f"\n### FIXED REGRESSIONS\n")
    has_changes = add_to_test_results_buffer(buffer, fixed_issues)
    if not has_changes:
        buffer.write(f"\nNo fixed regressions observed.\n")

    buffer.write(f"\n### UNSTABLE TESTS\n")
    has_changes = add_to_test_results_buffer(buffer, unstable_tests)
    if not has_changes:
        buffer.write(f"\nNo unstable tests observed.\n")


    buffer.write(f"\n---\nDisplay history for each test.\n")
    buffer.write(f"Sent every day if there were changes in the past 24 hours.\n")
    buffer.write(f"Legend: ✅ PASS   ❌ FAIL   ⚠️ INCONCLUSIVE\n")

    buffer.write(f"\nThis is an experimental report format. Please send feedback in!\n")
    buffer.write(f"Talk to us at kernelci@lists.linux.dev\n")

    buffer.write(f"Made with love by the KernelCI team - https://kernelci.org")

    report = {}
    report["content"] = buffer.getvalue()
    buffer.close()

    now = datetime.now(timezone.utc)
    report["title"] = f"[STATUS CHANGES] {tree_name}/{branch} - {now.strftime('%Y-%m-%d %H:%M %Z')}"

    print(report["content"])
    send_email_report(service, report, recipients, email_args)


def run_test_status_changes(service, conn, origin, path, email_args):
    data = read_yaml_file('data/test-status.yaml')
    for tree in data['trees'].values():
        if not kcidb_tree_checkout_last_24h(conn, origin, tree["giturl"]):
            continue

        path = tree["path"] if "path" in tree else '%'
        if "recipients" in tree:
            recipients = ', '.join(tree["recipients"])
        else:
            recipients = None

        evaluate_test_results(service, conn, origin, tree["giturl"], tree["branch"], path, email_args, recipients)


def create_and_send_issue_reports(service, conn, email_args):
    unsent_issues = get_unsent_issues()
    for issue_id, details in unsent_issues.items():
        if details["type"] != "build":
            continue
        generate_issue_report(service, conn, issue_id, email_args)


def main():
    service = gmail_setup_service()
    dbconn = kcidb_connect()
    origin = "maestro"

    parser = argparse.ArgumentParser(description="Run notifications script with subcommands.")
    parser.add_argument("--send", action="store_true", help="Send email report at the end.")
    parser.add_argument("--to", type=str, help="Recipient To: of the email")
    parser.add_argument("--cc", type=str, help="Recipient CC: of the email")
    parser.add_argument("--yes", action="store_true", help="Send email without asking for confirmation")
    parser.add_argument("--ignore-recipients", action="store_true", help="Ignore recipients.yaml file")

    subparsers = parser.add_subparsers(dest="command", required=True, help="Available subcommands")

    issues_parser = subparsers.add_parser("issues", help="Run the issue_summary function")

    issue_report_parser = subparsers.add_parser("issue_report", help="Run the issue_report function")
    issue_report_parser.add_argument("--id", type=str,
        help="Id of the issue in the Dashboard/KCIDB")
    issue_report_parser.add_argument("--all", action="store_true",
        help="Create reports for all issues not sent or not ignored")
    issue_report_parser.add_argument("--update-storage", "-u", action="store_true",
        help="Update json storage as we manipulate and report issues")
    issue_report_parser.add_argument("--ignore", type=str,
        help="Update json storage as we manipulate and report issues")

    tests_parser = subparsers.add_parser("tests", help="Check test status changes")
    tests_parser.add_argument("--giturl", type=str,
        help="git tree url as in the the KernelCI Dashboard")
    tests_parser.add_argument("--branch", type=str,
        help="git tree name as in the the KernelCI Dashboard")
    tests_parser.add_argument("--path", type=str,
        help="test path in SQL 'regex' format")
    tests_parser.add_argument("--run", action="store_true",
        help="Run for for trees configured at 'data/test-status.yaml'")

    args = parser.parse_args()

    email_args = SimpleNamespace()
    email_args.send = args.send
    email_args.yes = args.yes
    email_args.to = args.to
    email_args.cc = args.cc
    email_args.ignore_recipients = args.ignore_recipients

    if args.command == "issues":
        generate_issues_summary(dbconn, service, origin, email_args)
    elif args.command == "issue_report":
        email_args.update = args.update_storage
        if args.all:
            create_and_send_issue_reports(service, dbconn, email_args)
            return
        elif args.ignore:
            mark_issue_as_ignore(args.ignore)
            return
        else:
            generate_issue_report(service, dbconn, args.id, email_args)
    elif args.command == "tests":
            if args.run:
                run_test_status_changes(service, dbconn, origin, args.path, email_args)
            else:
                evaluate_test_results(service, dbconn, origin, args.giturl, args.branch, args.path, email_args)
            return


if __name__ == "__main__":
    main()