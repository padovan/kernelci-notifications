#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import jinja2
import json
import os
import sys

from collections import defaultdict
from datetime import datetime, timezone
from types import SimpleNamespace

from libs.email import *
from libs.kcidb import *


STORAGE_FILE = "found_issues.json"


def setup_jinja_template(file):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(sys.path[0], 'templates')))
    return env.get_template(file)


def exclude_already_found_and_store(issues):
    """
    Excludes issues that have already been found and store in the storage file.

    Args:
        issues: A list of dictionaries, where each dictionary represents an issue.

    Returns:
        A list of dictionaries containing only the new issues (those not in the storage file).
    """
    found_issues = {}

    # Load existing found issues from storage if the file exists
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, "r") as f:
                found_issues = json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {STORAGE_FILE}. Starting with empty issue list.")


    new_issues = []
    for issue in issues:
        issue_id = issue['id']  # Assuming 'id' is the unique identifier

        if issue_id not in found_issues:
            new_issues.append(issue)
            issue["sent"] = False
            issue["ignore"] = False
            found_issues[issue_id] = {
                "comment": issue["comment"],
                "type": issue["type"],
                "timestamp": issue["_timestamp"],
                "dashboard": f"https://dashboard.kernelci.org/issue/{issue["id"]}",
                "sent": issue["sent"],
                "ignore": issue["ignore"],
            }


    # Save the updated found issues to storage (overwriting the file)
    try:
        with open(STORAGE_FILE, "w") as f:
            json.dump(found_issues, f, indent=4, default=str) # indent for readability, default=str to handle datetime
    except Exception as e:
        print(f"Error saving found issues to {STORAGE_FILE}: {e}")

    return new_issues


def get_unsent_issues():
    """Collects all issues where 'sent' is False and 'ignore' is False."""
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    unsent_issues = {
        issue_id: details
        for issue_id, details in data.items()
        if not details.get("sent", False) and not details.get("ignore", False)
    }

    return unsent_issues


def mark_issues_as_sent(issues):
    """Marks issues as sent in the storage file only if they are already marked as sent in the provided issues list."""
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    # Update only issues where 'sent' is True in the provided list
    for issue_id, details in issues.items():
        if issue_id in data and details.get("sent") is True:
            data[issue_id]["sent"] = True
            if details.get("message_id"):
                data[issue_id]["message_id"] = details.get("message_id")

    # Write back to the file
    with open(STORAGE_FILE, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4, ensure_ascii=False)


def generate_issues_summary(dbconn, service, origin, email_args):
    issues = kcidb_new_issues(dbconn)
    build_issues = []
    boot_issues = []
    for issue in issues:
        if issue["build_id"]:
            issue["type"] = "build"
            build_issues.append(issue)
        elif issue["test_id"]:
            issue["type"] = "boot"
            boot_issues.append(issue)

    new_build_issues = exclude_already_found_and_store(build_issues)
    new_boot_issues = exclude_already_found_and_store(boot_issues)
    if not new_build_issues and not new_boot_issues:
        return None

    template = setup_jinja_template('issues.txt.j2')
    report= {}
    now = datetime.now(timezone.utc)
    report["content"] = template.render(build_issues=build_issues, boot_issues=boot_issues)
    report["title"] = f"new issues summary - {now.strftime("%Y-%m-%d %H:%M %Z")}"

    send_email_report(service, report, email_args)


def generate_build_issue_report(issue, incidents):
    template = setup_jinja_template('issue_build.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, builds=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (build){snippet}"
    return report


def generate_boot_issue_report(issue, incidents):
    template = setup_jinja_template('issue_boot.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, boots=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (boot){snippet}"
    return report


def generate_issue_report(service, conn, issue_id, email_args):
    result = kcidb_issue_details(conn, issue_id)
    if not result:
        print("issue not found!")
        sys.exit(-1)
    issue = result[0]
    if issue["build_id"]:
        incidents = kcidb_build_incidents(conn, issue_id)
        report = generate_build_issue_report(issue, incidents)
    elif issue["test_id"]:
        incidents = kcidb_test_incidents(conn, issue_id)
        for incident in incidents:
            last_test = kcidb_last_test_without_issue(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            last_test = kcidb_last_test_without_issue_koike(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            incident["last_pass"] = last_test[0]["start_time"]
            incident["last_pass_commit"] = last_test[0]["git_commit_hash"]
            incident["last_pass_id"] = last_test[0]["id"]
        report = generate_boot_issue_report(issue, incidents)

    send_email_report(service, report, email_args)


def create_and_send_issue_reports(service, conn, email_args):
    unsent_issues = get_unsent_issues()
    for issue_id, details in unsent_issues.items():
        if details["type"] != "build":
            continue
        generate_issue_report(service, conn, issue_id, email_args)
        details["sent"] = True

    mark_issues_as_sent(unsent_issues)


def main():
    service = gmail_setup_service()
    dbconn = kcidb_connect()
    origin = "maestro"

    parser = argparse.ArgumentParser(description="Run notifications script with subcommands.")
    parser.add_argument("--send", action="store_true", help="Send email report at the end.")
    parser.add_argument("--to", type=str, help="Recipient To: of the email")
    parser.add_argument("--cc", type=str, help="Recipient CC: of the email")
    parser.add_argument("--yes", action="store_true", help="Send email without asking for confirmation")

    subparsers = parser.add_subparsers(dest="command", required=True, help="Available subcommands")

    issues_parser = subparsers.add_parser("issues", help="Run the issue_summary function")

    issue_report_parser = subparsers.add_parser("issue_report", help="Run the issue_report function")
    issue_report_parser.add_argument("--id", type=str,
        help="Id of the issue in the Dashboard/KCIDB")
    issue_report_parser.add_argument("--send-all", action="store_true",
        help="Automatically send issue reports for supported types")

    tests_parser = subparsers.add_parser("tests", help="Check test status changes")

    args = parser.parse_args()

    email_args = SimpleNamespace()
    email_args.send = args.send
    email_args.yes = args.yes
    email_args.to = args.to
    email_args.cc = args.cc

    if args.command == "issues":
        generate_issues_summary(dbconn, service, origin, email_args)
    elif args.command == "issue_report":
        if args.send_all:
            create_and_send_issue_reports(service, dbconn, email_args)
            return
        else:
            generate_issue_report(service, dbconn, args.id, email_args)


if __name__ == "__main__":
    main()