#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import jinja2
import json
import os
import base64
import sys

from datetime import datetime, timezone
from email.message import EmailMessage

from libs.gmail_api import *
from libs.kcidb import *


def setup_jinja_template(file):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(sys.path[0], 'templates')))
    return env.get_template(file)


def exclude_issues_already_found(issues):
    """
    Excludes issues that have already been found and stored in the storage file.

    Args:
        issues: A list of dictionaries, where each dictionary represents an issue.

    Returns:
        A list of dictionaries containing only the new issues (those not in the storage file).
    """
    STORAGE_FILE = "found_issues.json"
    found_issues = {}

    # Load existing found issues from storage if the file exists
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, "r") as f:
                found_issues = json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {STORAGE_FILE}. Starting with empty issue list.")


    new_issues = []
    for issue in issues:
        issue_id = issue['id']  # Assuming 'id' is the unique identifier

        if issue_id not in found_issues:
            new_issues.append(issue)
            found_issues[issue_id] = {
                "comment": issue["comment"],
                "type": issue["type"],
                "timestamp": issue["_timestamp"],
                "dashboard": f"https://dashboard.kernelci.org/issue/{issue["id"]}",
                "found": True
                }


    # Save the updated found issues to storage (overwriting the file)
    try:
        with open(STORAGE_FILE, "w") as f:
            json.dump(found_issues, f, indent=4, default=str) # indent for readability, default=str to handle datetime
    except Exception as e:
        print(f"Error saving found issues to {STORAGE_FILE}: {e}")

    return new_issues


def generate_issues_summary(conn, origin):
    issues = kcidb_new_issues(conn)
    build_issues = []
    boot_issues = []
    for issue in issues:
        if issue["build_id"]:
            issue["type"] = "build"
            build_issues.append(issue)
        elif issue["test_id"]:
            issue["type"] = "boot"
            boot_issues.append(issue)

    new_build_issues = exclude_issues_already_found(build_issues)
    new_boot_issues = exclude_issues_already_found(boot_issues)
    if not new_build_issues and not new_boot_issues:
        return None

    template = setup_jinja_template('issues.txt.j2')
    report= {}
    now = datetime.now(timezone.utc)
    report["content"] = template.render(build_issues=build_issues, boot_issues=boot_issues)
    report["title"] = f"new issues summary - {now.strftime("%Y-%m-%d %H:%M %Z")}"
    return report


def generate_build_issue_report(issue, incidents):
    template = setup_jinja_template('issue_build.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, builds=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 60 else issue["comment"][:57]+ "..."
    report["title"] = f"{issue["tree_name"]}/{issue["git_repository_branch"]}: new build regression: {snippet}"
    return report


def generate_boot_issue_report(issue, incidents):
    template = setup_jinja_template('issue_boot.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, boots=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 60 else issue["comment"][:57]+ "..."
    report["title"] = f"{issue["tree_name"]}/{issue["git_repository_branch"]}: new boot regression: {snippet}"
    return report


def generate_issue_report(conn, issue_id):
    result = kcidb_issue_details(conn, issue_id)
    if not result:
        print("issue not found!")
        sys.exit(-1)
    issue = result[0]
    if issue["build_id"]:
        incidents = kcidb_build_incidents(conn, issue_id)
        return generate_build_issue_report(issue, incidents)
    elif issue["test_id"]:
        incidents = kcidb_test_incidents(conn, issue_id)
        for incident in incidents:
            last_test = kcidb_last_test_without_issue(conn, issue, incident)
            print(last_test[0]["_timestamp"])
            print(last_test[0]["git_repository_url"])
            print(last_test[0]["status"])
            incident["last_pass"] = last_test[0]["_timestamp"]
            incident["last_pass_commit"] = last_test[0]["git_commit_hash"]
            incident["last_pass_id"] = last_test[0]["id"]
        return generate_boot_issue_report(issue, incidents)


def create_email(sender, to, subject, message_text, cc):
    message = EmailMessage()
    message.set_content(message_text)
    # Set email headers
    if to:
        message['to'] = to
    else:
        message['to'] = "gustavo.padovan@collabora.com"
        #message['to'] = "kernelci-results@groups.io"
    if cc:
        message['cc'] = cc
    message['from'] = sender
    message['subject'] = subject

    # Encode the message as base64
    raw = base64.urlsafe_b64encode(message.as_bytes()).decode()
    return {'raw': raw}


def ask_confirmation():
    while True:
        choice = input(">> Do you want to send the email? (y/n): ").strip().lower()
        if choice in ["y", "yes"]:
            return True
        elif choice in ["n", "no"]:
            return False
        else:
            print("Please enter 'y' or 'n'.")


def send_email_report(service, report, to, cc=None, yes=False):
    sender_email = "KernelCI bot <bot@kernelci.org>"
    subject = report["title"]
    message_text = report["content"]

    if not yes:
        print("===================")
        print(f"Subject: {subject}")
        print(f"To: {to}")
        if cc:
            print(f"Cc: {cc}")
        print(message_text)
        if not ask_confirmation():
            print("Email sending aborted.")
            return


    print(f"sending {subject}.")

    email = create_email(sender_email, to, subject, message_text, cc)
    gmail_send_email(service, 'me', email)


def main():
    service = gmail_setup_service()
    conn = kcidb_connect()
    origin = "maestro"

    parser = argparse.ArgumentParser(description="Run notifications script with subcommands.")
    parser.add_argument("--send", action="store_true", help="Send email report at the end.")
    parser.add_argument("--to", type=str, help="Recipient To: of the email")
    parser.add_argument("--cc", type=str, help="Recipient CC: of the email")
    parser.add_argument("--yes", action="store_true", help="Send email without asking for confirmation")

    subparsers = parser.add_subparsers(dest="command", required=True, help="Available subcommands")

    issues_parser = subparsers.add_parser("issues", help="Run the issue_summary function")

    issue_report_parser = subparsers.add_parser("issue_report", help="Run the issue_report function")
    issue_report_parser.add_argument("--id", type=str , required=True,
        help="Id of the issue in the Dashboard/KCIDB")

    args = parser.parse_args()

    if args.command == "issues":
        report = generate_issues_summary(conn, origin)
    elif args.command == "issue_report":
        report = generate_issue_report(conn, args.id)

    if not report:
        print("No new regressions.")
        return

    if args.send:
        send_email_report(service, report, args.to, args.cc, args.yes)
    else:
        print("\n==============================================")
        print(f"new report:\n> {report["title"]}")
        print(report["content"])

if __name__ == "__main__":
    main()