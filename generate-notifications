#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import jinja2
import json
import os
import sys
import yaml

from collections import defaultdict
from datetime import datetime, timezone
from types import SimpleNamespace

from libs.email import *
from libs.kcidb import *


STORAGE_FILE = "found_issues.json"


def setup_jinja_template(file):
    env = jinja2.Environment(loader=jinja2.FileSystemLoader(os.path.join(sys.path[0], 'templates')))
    return env.get_template(file)


def exclude_already_found_and_store(issues):
    """
    Excludes issues that have already been found and store in the storage file.

    Args:
        issues: A list of dictionaries, where each dictionary represents an issue.

    Returns:
        A list of dictionaries containing only the new issues (those not in the storage file).
    """
    found_issues = {}

    # Load existing found issues from storage if the file exists
    if os.path.exists(STORAGE_FILE):
        try:
            with open(STORAGE_FILE, "r") as f:
                found_issues = json.load(f)
        except json.JSONDecodeError:
            print(f"Warning: Could not decode JSON from {STORAGE_FILE}. Starting with empty issue list.")


    new_issues = []
    for issue in issues:
        issue_id = issue['id']  # Assuming 'id' is the unique identifier

        if not found_issues.get(issue_id):
            new_issues.append(issue)
            issue["sent"] = False
            issue["ignore"] = False
            found_issues[issue_id] = {
                "comment": issue["comment"],
                "type": issue["type"],
                "timestamp": issue["_timestamp"],
                "dashboard": f"https://dashboard.kernelci.org/issue/{issue["id"]}",
                "sent": issue["sent"],
                "ignore": issue["ignore"],
            }


    # Save the updated found issues to storage (overwriting the file)
    try:
        with open(STORAGE_FILE, "w") as f:
            json.dump(found_issues, f, indent=4, default=str) # indent for readability, default=str to handle datetime
    except Exception as e:
        print(f"Error saving found issues to {STORAGE_FILE}: {e}")

    return new_issues


def get_unsent_issues():
    """Collects all issues where 'sent' is False and 'ignore' is False."""
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    unsent_issues = {
        issue_id: details
        for issue_id, details in data.items()
        if not details.get("sent", False) and not details.get("ignore", False)
    }

    return unsent_issues


def mark_issue_as_sent(issue_id, msg_id):
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    if issue_id in data:
        data[issue_id]["sent"] = True
        data[issue_id]["message_id"] = msg_id

        with open(STORAGE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)


def mark_issue_as_ignore(issue_id):
    with open(STORAGE_FILE, "r", encoding="utf-8") as f:
        data = json.load(f)

    if issue_id in data:
        data[issue_id]["ignore"] = True

        with open(STORAGE_FILE, "w", encoding="utf-8") as f:
            json.dump(data, f, indent=4, ensure_ascii=False)


def get_recipient_list(tree_name):
    """
    Read recipients from a YAML file for a given tree name.

    Args:
        tree_name (str): Name of the tree (e.g., 'android', 'stable', 'next')

    Returns:
        str: Comma-separated list of email addresses for the specified tree
             Returns None if tree is not found
    """
    try:
        with open('data/recipients.yaml', 'r') as file:
            data = yaml.safe_load(file)

        if tree_name in data['trees']:
            recipients = data['trees'][tree_name]
            return ', '.join(recipients)

        return None

    except FileNotFoundError:
        print("Error: data/recipients.yaml file not found")
        return None
    except yaml.YAMLError as e:
        print(f"Error parsing YAML file: {e}")
        return None
    except (KeyError, TypeError) as e:
        print(f"Error accessing tree data: {e}")
        return None


def generate_issues_summary(dbconn, service, origin, email_args):
    issues = kcidb_new_issues(dbconn)
    build_issues = []
    boot_issues = []
    for issue in issues:
        if issue["build_id"]:
            issue["type"] = "build"
            build_issues.append(issue)
        elif issue["test_id"]:
            issue["type"] = "boot"
            boot_issues.append(issue)

    new_build_issues = exclude_already_found_and_store(build_issues)
    new_boot_issues = exclude_already_found_and_store(boot_issues)
    if not new_build_issues and not new_boot_issues:
        print("No new issues")
        return None

    template = setup_jinja_template('issues.txt.j2')
    report= {}
    now = datetime.now(timezone.utc)
    report["content"] = template.render(build_issues=new_build_issues, boot_issues=new_boot_issues)
    report["title"] = f"new issues summary - {now.strftime("%Y-%m-%d %H:%M %Z")}"

    send_email_report(service, report, email_args)


def generate_build_issue_report(issue, incidents):
    template = setup_jinja_template('issue_build.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, builds=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (build){snippet}"
    return report


def generate_boot_issue_report(issue, incidents):
    template = setup_jinja_template('issue_boot.txt.j2')
    report= {}
    report["content"] = template.render(issue=issue, boots=incidents)
    snippet = issue["comment"] if len(issue["comment"]) <= 70 else issue["comment"][:67]+ "..."
    report["title"] = f"[REGRESSION] {issue["tree_name"]}/{issue["git_repository_branch"]}: (boot){snippet}"
    return report


def generate_issue_report(service, conn, issue_id, email_args):
    result = kcidb_issue_details(conn, issue_id)
    if not result:
        print("issue not found!")
        sys.exit(-1)
    issue = result[0]
    if issue["build_id"]:
        incidents = kcidb_build_incidents(conn, issue_id)
        report = generate_build_issue_report(issue, incidents)
    elif issue["test_id"]:
        incidents = kcidb_test_incidents(conn, issue_id)
        for incident in incidents:
            last_test = kcidb_last_test_without_issue(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            last_test = kcidb_last_test_without_issue_koike(conn, issue, incident)
            print(f"https://dashboard.kernelci.org/test/{last_test[0]["id"]}")
            incident["last_pass"] = last_test[0]["start_time"]
            incident["last_pass_commit"] = last_test[0]["git_commit_hash"]
            incident["last_pass_id"] = last_test[0]["id"]
        report = generate_boot_issue_report(issue, incidents)

    cc = get_recipient_list("android")
    if email_args.cc:
        email_args.cc = ', '.join([email_args.cc, cc])
    else:
        email_args.cc = cc

    msg_id = send_email_report(service, report, email_args)

    if msg_id and email_args.update:
        mark_issue_as_sent(issue_id, msg_id)


def evaluate_test_results(conn, origin, tree, branch):
    tests = kcidb_tests_results(conn, origin, tree, branch)
    print(f"Test results changes for {tree}/{branch} (origin: {origin})")

    # First group by platform, then by path
    grouped = defaultdict(lambda: defaultdict(list))

    for t in tests:
        platform = t["environment_misc"].get("platform", "unknown")
        grouped[platform][t["path"]].append(t)

    for platform, paths in grouped.items():
        printed_platform = False

        for path, test_group in paths.items():

            unique_statuses = {t["status"] for t in test_group}
            if len(unique_statuses) == 1:
                continue

            if not printed_platform:
                sys.stdout.write(f"\nHardware: {platform}\n")
                printed_platform = True

            for t in test_group:
                if t["status"] == "PASS":
                    sys.stdout.write("✅ ")
                elif t["status"] == "FAIL":
                    sys.stdout.write("❌ ")
                else:  # Inconclusive or other statuses
                    sys.stdout.write("❔ ")

            sys.stdout.write(f"{path}\n")


def create_and_send_issue_reports(service, conn, email_args):
    unsent_issues = get_unsent_issues()
    for issue_id, details in unsent_issues.items():
        if details["type"] != "build":
            continue
        generate_issue_report(service, conn, issue_id, email_args)


def main():
    service = gmail_setup_service()
    dbconn = kcidb_connect()
    origin = "maestro"

    parser = argparse.ArgumentParser(description="Run notifications script with subcommands.")
    parser.add_argument("--send", action="store_true", help="Send email report at the end.")
    parser.add_argument("--to", type=str, help="Recipient To: of the email")
    parser.add_argument("--cc", type=str, help="Recipient CC: of the email")
    parser.add_argument("--yes", action="store_true", help="Send email without asking for confirmation")

    subparsers = parser.add_subparsers(dest="command", required=True, help="Available subcommands")

    issues_parser = subparsers.add_parser("issues", help="Run the issue_summary function")

    issue_report_parser = subparsers.add_parser("issue_report", help="Run the issue_report function")
    issue_report_parser.add_argument("--id", type=str,
        help="Id of the issue in the Dashboard/KCIDB")
    issue_report_parser.add_argument("--send-all", action="store_true",
        help="Automatically send issue reports for supported types")
    issue_report_parser.add_argument("--update-storage", "-u", action="store_true",
        help="Update json storage as we manipulate and report issues")
    issue_report_parser.add_argument("--ignore", type=str,
        help="Update json storage as we manipulate and report issues")

    tests_parser = subparsers.add_parser("tests", help="Check test status changes")
    tests_parser.add_argument("--tree", type=str,
        help="git tree name as in the the KernelCI Dashboard")
    tests_parser.add_argument("--branch", type=str,
        help="git tree name as in the the KernelCI Dashboard")

    args = parser.parse_args()

    email_args = SimpleNamespace()
    email_args.send = args.send
    email_args.yes = args.yes
    email_args.to = args.to
    email_args.cc = args.cc

    if args.command == "issues":
        generate_issues_summary(dbconn, service, origin, email_args)
    elif args.command == "issue_report":
        email_args.update = args.update_storage
        if args.send_all:
            create_and_send_issue_reports(service, dbconn, email_args)
            return
        elif args.ignore:
            mark_issue_as_ignore(args.ignore)
            return
        else:
            generate_issue_report(service, dbconn, args.id, email_args)
    elif args.command == "tests":
            evaluate_test_results(dbconn, origin, args.tree, args.branch)
            return


if __name__ == "__main__":
    main()